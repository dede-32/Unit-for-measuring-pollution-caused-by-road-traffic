#include <heltec_unofficial.h>
#include "PowerManager.h"
#include <bsec2.h>
#include <Preferences.h>



#define SDA_PIN 18
#define SCL_PIN 20
#define PANIC_LED LED_BUILTIN
#define ERROR_DUR 1000
#define SAMPLE_RATE BSEC_SAMPLE_RATE_ULP  // = 5 minut

Bsec2 envSensor;
PowerManager pm;
Preferences prefs;

unsigned long lastMeasurementTime = 0;
bool newDataAvailable = false;

void newDataCallback(const bme68xData data, const bsecOutputs outputs, Bsec2 bsec);
void checkBsecStatus(Bsec2 bsec);

void setup() {
  Serial.begin(115200);
  
  Wire.begin(SDA_PIN, SCL_PIN);
  

  // Register sensors and their power control pins
  pm.addSensor("SCD41", 5, false);
  pm.addSensor("SPS30", 7, false);
  pm.addSensor("BME688", 4, true); // Always on for AQI
  pm.addSensor("DMM4026", 6, false); 
  pm.addSensor("EN", 19, false);

  prefs.begin("bsec", true);  // readonly
  int stateLen = prefs.getBytesLength("iaqState");
  
  if (stateLen > 0) {
    uint8_t state[stateLen];
    prefs.getBytes("iaqState", state, stateLen);
    if (envSensor.setState(state)) {
      Serial.println("✅ BSEC state loaded from NVS");
    } else {
      Serial.println("⚠️ Failed to load BSEC state");
    }
  } else {
    Serial.println("ℹ️ No saved BSEC state found");
  }
  prefs.end();



  

  if (!envSensor.begin(BME68X_I2C_ADDR_LOW, Wire)) {
    checkBsecStatus(envSensor);
  }

  envSensor.setTemperatureOffset(TEMP_OFFSET_ULP);

  bsecSensor sensorList[] = {
    BSEC_OUTPUT_IAQ,
    BSEC_OUTPUT_RAW_TEMPERATURE,
    BSEC_OUTPUT_RAW_PRESSURE,
    BSEC_OUTPUT_RAW_HUMIDITY,
    BSEC_OUTPUT_RAW_GAS,
    BSEC_OUTPUT_STABILIZATION_STATUS,
    BSEC_OUTPUT_RUN_IN_STATUS,
    BSEC_OUTPUT_SENSOR_HEAT_COMPENSATED_TEMPERATURE,
    BSEC_OUTPUT_SENSOR_HEAT_COMPENSATED_HUMIDITY,
    BSEC_OUTPUT_STATIC_IAQ,
    BSEC_OUTPUT_CO2_EQUIVALENT,
    BSEC_OUTPUT_BREATH_VOC_EQUIVALENT,
    BSEC_OUTPUT_GAS_PERCENTAGE,
    BSEC_OUTPUT_COMPENSATED_GAS
  };

  if (!envSensor.updateSubscription(sensorList, ARRAY_LEN(sensorList), SAMPLE_RATE)) {
    checkBsecStatus(envSensor);
  }

  envSensor.attachCallback(newDataCallback);

  Serial.println("BSEC2 ready. First measurement coming...");
}

void loop() {
  newDataAvailable = false;

  // Aktivně voláme run(), dokud nenastane čas měření
  while (!newDataAvailable) {
    if (!envSensor.run()) {
      checkBsecStatus(envSensor);
    }
    delay(100);  // ne moc často, ale dost na to trefit přesný čas
  }

  // Uložíme čas posledního měření
  lastMeasurementTime = millis();

  // Zbývající čas do příštího měření – dáme rezervu
  const unsigned long sleepDurationMs = 300000UL - 10000UL; // 5 min - 10 sec

  Serial.print("Going to light sleep for ");
  Serial.print(sleepDurationMs / 1000);
  Serial.println(" seconds...");
  delay(100);

  esp_sleep_enable_timer_wakeup((uint64_t)sleepDurationMs * 1000ULL);
  esp_light_sleep_start();
}

void newDataCallback(const bme68xData data, const bsecOutputs outputs, Bsec2 bsec) {
  if (!outputs.nOutputs) return;

  Serial.println("\nBSEC outputs:");
  Serial.println("-----------------------------------------------------");

  for (uint8_t i = 0; i < outputs.nOutputs; i++) {
    const bsecData output = outputs.output[i];

    switch (output.sensor_id) {
      case BSEC_OUTPUT_IAQ:
        Serial.printf("IAQ: %.2f (accuracy: %d)\n", output.signal, output.accuracy);
        break;
      case BSEC_OUTPUT_STATIC_IAQ:
        Serial.printf("Static IAQ: %.2f\n", output.signal);
        break;
      case BSEC_OUTPUT_CO2_EQUIVALENT:
        Serial.printf("CO2 equivalent: %.2f ppm\n", output.signal);
        break;
      case BSEC_OUTPUT_BREATH_VOC_EQUIVALENT:
        Serial.printf("bVOC equivalent: %.2f ppm\n", output.signal);
        break;
      case BSEC_OUTPUT_RAW_TEMPERATURE:
        Serial.printf("Raw temperature: %.2f °C\n", output.signal);
        break;
      case BSEC_OUTPUT_SENSOR_HEAT_COMPENSATED_TEMPERATURE:
        Serial.printf("Compensated temperature: %.2f °C\n", output.signal);
        break;
      case BSEC_OUTPUT_RAW_PRESSURE:
        Serial.printf("Raw pressure: %.2f hPa\n", output.signal);
        break;
      case BSEC_OUTPUT_RAW_HUMIDITY:
        Serial.printf("Raw humidity: %.2f %%\n", output.signal);
        break;
      case BSEC_OUTPUT_SENSOR_HEAT_COMPENSATED_HUMIDITY:
        Serial.printf("Compensated humidity: %.2f %%\n", output.signal);
        break;
      case BSEC_OUTPUT_RAW_GAS:
        Serial.printf("Raw gas resistance: %.2f Ohm\n", output.signal);
        break;
      case BSEC_OUTPUT_COMPENSATED_GAS:
        Serial.printf("Compensated gas: %.2f Ohm\n", output.signal);
        break;
      case BSEC_OUTPUT_GAS_PERCENTAGE:
        Serial.printf("Gas percentage: %.2f %%\n", output.signal);
        break;
      case BSEC_OUTPUT_STABILIZATION_STATUS:
        Serial.printf("Stabilization status: %s\n", output.signal > 0.5 ? "Stable" : "Stabilizing");
        break;
      case BSEC_OUTPUT_RUN_IN_STATUS:
        Serial.printf("Run-in status: %s\n", output.signal > 0.5 ? "Completed" : "Running");
        break;

        static bool stateSaved = false;

        if (!stateSaved && output.sensor_id == BSEC_OUTPUT_IAQ && output.accuracy == 3) {
          uint8_t state[BSEC_MAX_STATE_BLOB_SIZE];
          uint32_t stateLen = envSensor.getState(state);
        
          prefs.begin("bsec", false);  // write mode
          prefs.putBytes("iaqState", state, stateLen);
          prefs.end();
        
          Serial.println("BSEC state saved to NVS");
          stateSaved = true;
        }
    }
  }

  Serial.println("-----------------------------------------------------\n");
}

void checkBsecStatus(Bsec2 bsec) {
  if (bsec.status < BSEC_OK) {
    Serial.println("BSEC error: " + String(bsec.status));
    while (true);
  }
  if (bsec.sensor.status < BME68X_OK) {
    Serial.println("BME68X error: " + String(bsec.sensor.status));
    while (true);
  }
}